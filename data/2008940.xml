<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle><![CDATA[Collaborative Research: CNS Core: Small: RUI: Intelligent Developer Infrastructure]]></AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>07/15/2020</AwardEffectiveDate>
<AwardExpirationDate>06/30/2024</AwardExpirationDate>
<AwardTotalIntnAmount>176018.00</AwardTotalIntnAmount>
<AwardAmount>176018</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05050000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CNS</Abbreviation>
<LongName>Division Of Computer and Network Systems</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Jason Hallstrom</SignBlockName>
<PO_EMAI>jhallstr@nsf.gov</PO_EMAI>
<PO_PHON>7032920000</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Software engineers use development tools to help develop software.  The tools may compile computer code into runnable programs, debug programs to find and fix errors, and deploy software across systems. Existing tools used for these tasks are complex. The misuse of tools can introduce errors and inefficiencies. For example, a popular tool for compiling code, called "make", automates compilation with a user-provided encoding of the task. Users of "make" must produce either a simple but inefficient encoding, or an efficient but complex encoding with an increased risk of error. This project introduces techniques that correctly and efficiently automate compilation, debugging, and deployment tasks without programming.&lt;br/&gt;&lt;br/&gt;This project proposes a core technique built on dependency graphs. A dependency graph is generated by observing a piece of software interacting with its environment as it runs. This project proposes three tools that leverage dependency graphs to automate software development tasks. First, Riker correctly and efficiently automates compilation tasks based on a single example compilation.  Second, Scotty answers high-level queries about where a program went wrong by observing the program's execution.  Third, Locutus automates software deployment tasks by observing the user during an example deployment.&lt;br/&gt;&lt;br/&gt;This project has the potential to impact the day-to-day work of software developers significantly. Automating support tasks with minimal developer input reduces the cost of software development and guarantees that support tasks are correct by construction. These changes free software developers to focus on their core tasks. This project will provide undergraduate students at Grinnell College and Williams College with opportunities to participate in research, and will broaden participation by including students from underrepresented groups.&lt;br/&gt;&lt;br/&gt;All products of this project will be hosted at https://github.com/curtsinger-lab/idi-grant. Code produced in the course of this project will be released under the MIT license. Modifications to existing software will be released under a compatible open source license. Any non-code products will comprise only publicly-available, non-confidential information, and will be released under a Creative Commons license.  All products of this project will be preserved for at least five years after the conclusion of the project.&lt;br/&gt;&lt;br/&gt;This award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.</AbstractNarration>
<MinAmdLetterDate>07/13/2020</MinAmdLetterDate>
<MaxAmdLetterDate>07/13/2020</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>2008940</AwardID>
<Investigator>
<FirstName>Charles</FirstName>
<LastName>Curtsinger</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Charles Curtsinger</PI_FULL_NAME>
<EmailAddress><![CDATA[curtsinger@grinnell.edu]]></EmailAddress>
<NSF_ID>000702112</NSF_ID>
<StartDate>07/13/2020</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name><![CDATA[Grinnell College]]></Name>
<CityName>GRINNELL</CityName>
<ZipCode>501122227</ZipCode>
<PhoneNumber>6412694983</PhoneNumber>
<StreetAddress><![CDATA[733 BROAD ST]]></StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Iowa</StateName>
<StateCode>IA</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>IA02</CONGRESS_DISTRICT_ORG>
<ORG_UEI_NUM>NRFXPGZU88G2</ORG_UEI_NUM>
<ORG_LGL_BUS_NAME>THE TRUSTEES OF GRINNELL COLLEGE</ORG_LGL_BUS_NAME>
<ORG_PRNT_UEI_NUM/>
</Institution>
<Performance_Institution>
<Name><![CDATA[Grinnell College]]></Name>
<CityName/>
<StateCode>IA</StateCode>
<ZipCode>501122227</ZipCode>
<StreetAddress/>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Iowa</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>IA02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>735400</Code>
<Text>CSR-Computer Systems Research</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<Appropriation>
<Code>0120</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Fund>
<Code>01002021DB</Code>
<Name><![CDATA[NSF RESEARCH & RELATED ACTIVIT]]></Name>
<FUND_SYMB_ID>040100</FUND_SYMB_ID>
</Fund>
<FUND_OBLG>2020~176018</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Software developers rely on build systems throughout a project's lifecycle. Build systems describe the steps required to turn a project's code and resources into a runnable program. Critically, these build systems must be both fast and correct to be useful. Developers run builds frequently during the software development process, and builds must correctly account for changes and updates anywhere in a project and its dependencies.</p> <p>Prior build systems ask users to specify the main steps required to build a piece of software, as well as the dependencies and outputs of each major step. This forces developers to choose between speed and correctness. A simple build specification is easy to write correctly but is rarely efficient. More efficient build specifications can be faster but often contain errors that can result in incorrect or broken builds. Our work addresses this challenge by making builds both easy to specify and automatically correct.</p> <p>Our key insight is that software builds reveal their dependencies as they run. Any files read during the build are dependencies, and the files written during the build are outputs. We developed a new build system called Riker that observes these dependencies and outputs for real builds. Riker uses the dependency information from the previous build to update the build's output any time a project's dependencies are changed. Riker is also able to run a subset of a build's major steps, skipping any whose inputs are unchanged since the last build. Riker's design ensures that its builds are correct and run as few steps as possible in response to the changes since the last build.</p> <p>Riker is an effective build tool. We used Riker to replace the existing build systems for several large software projects. We use both Riker and the project's default build system to run builds of each project over a series of changes developers saved in the project's code repository. Riker is nearly as efficient as the projects' default build systems over these incremental builds with none of the risk of errors from incorrect dependency information. Riker builds are also much easier to specify; many software projects have build systems specified over hundreds to thousands of lines, while most Riker builds can be specified in just a few lines without sacrificing efficiency.</p> <p>Recently, we have explored extensions to Riker that would allow it to work for system orchestration tasks. System orchestration is any work that involves managing the files and software across separate computers. Existing tools for system orchestration have similar downsides to legacy build systems; users must choose between simple specifications or efficient updates. We believe Riker's automatic dependency and output discovery could be beneficial in this domain as well.</p> <p>Riker is an open-source software project and is currently available for Linux. We are exploring strategies for porting Riker to other platforms.</p><br> <p>  Last Modified: 11/10/2024<br> Modified by: Charles&nbsp;Curtsinger</p></div> <div class="porSideCol" ></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  Software developers rely on build systems throughout a project's lifecycle. Build systems describe the steps required to turn a project's code and resources into a runnable program. Critically, these build systems must be both fast and correct to be useful. Developers run builds frequently during the software development process, and builds must correctly account for changes and updates anywhere in a project and its dependencies.   Prior build systems ask users to specify the main steps required to build a piece of software, as well as the dependencies and outputs of each major step. This forces developers to choose between speed and correctness. A simple build specification is easy to write correctly but is rarely efficient. More efficient build specifications can be faster but often contain errors that can result in incorrect or broken builds. Our work addresses this challenge by making builds both easy to specify and automatically correct.   Our key insight is that software builds reveal their dependencies as they run. Any files read during the build are dependencies, and the files written during the build are outputs. We developed a new build system called Riker that observes these dependencies and outputs for real builds. Riker uses the dependency information from the previous build to update the build's output any time a project's dependencies are changed. Riker is also able to run a subset of a build's major steps, skipping any whose inputs are unchanged since the last build. Riker's design ensures that its builds are correct and run as few steps as possible in response to the changes since the last build.   Riker is an effective build tool. We used Riker to replace the existing build systems for several large software projects. We use both Riker and the project's default build system to run builds of each project over a series of changes developers saved in the project's code repository. Riker is nearly as efficient as the projects' default build systems over these incremental builds with none of the risk of errors from incorrect dependency information. Riker builds are also much easier to specify; many software projects have build systems specified over hundreds to thousands of lines, while most Riker builds can be specified in just a few lines without sacrificing efficiency.   Recently, we have explored extensions to Riker that would allow it to work for system orchestration tasks. System orchestration is any work that involves managing the files and software across separate computers. Existing tools for system orchestration have similar downsides to legacy build systems; users must choose between simple specifications or efficient updates. We believe Riker's automatic dependency and output discovery could be beneficial in this domain as well.   Riker is an open-source software project and is currently available for Linux. We are exploring strategies for porting Riker to other platforms.     Last Modified: 11/10/2024       Submitted by: CharlesCurtsinger]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
