<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle><![CDATA[AF: Small: Randomness Extraction and Pseudorandomness]]></AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>10/01/2020</AwardEffectiveDate>
<AwardExpirationDate>09/30/2023</AwardExpirationDate>
<AwardTotalIntnAmount>400000.00</AwardTotalIntnAmount>
<AwardAmount>400000</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Peter Brass</SignBlockName>
<PO_EMAI>pbrass@nsf.gov</PO_EMAI>
<PO_PHON>7032922182</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Random numbers are surprisingly useful in computer science. For example, they are used for simulations of complex systems, such as the weather and the economy.  In addition, randomness is essential for "streaming algorithms," where there is so much data arriving that it is impossible to store it all.  Moreover, randomness is vital for computer security.  While randomness has many applications, truly random numbers are difficult to obtain.  It is therefore important to develop techniques to get by with less randomness or lower quality randomness.  The main tool to reduce the amount of randomness required is a pseudorandom number generator. In contrast, the main tool to reduce the quality of randomness required is a randomness extractor.&lt;br/&gt;&lt;br/&gt;This proposal addresses important questions about pseudorandom generators and randomness extractors that relate to the investigator's recent work.  For example, the investigator and his student gave an efficient algorithm that extracts randomness from two independent sources of low-quality randomness that was dramatically better than previously known. However, the error is too large for applications in cryptography. The investigator proposes to improve this, as well as work on other aspects of randomness extraction.  The investigator also proposes to construct pseudorandom generators that work for large classes of randomized algorithms, such as those using a small amount of memory.  Finally, the investigator proposes work connecting these objects to seemingly unrelated areas, such as big data in the form of streaming algorithms.&lt;br/&gt;&lt;br/&gt;This award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.</AbstractNarration>
<MinAmdLetterDate>07/24/2020</MinAmdLetterDate>
<MaxAmdLetterDate>07/24/2020</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>2008076</AwardID>
<Investigator>
<FirstName>David</FirstName>
<LastName>Zuckerman</LastName>
<PI_MID_INIT>I</PI_MID_INIT>
<PI_SUFX_NAME/>
<PI_FULL_NAME>David I Zuckerman</PI_FULL_NAME>
<EmailAddress><![CDATA[diz@utexas.edu]]></EmailAddress>
<NSF_ID>000181714</NSF_ID>
<StartDate>07/24/2020</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name><![CDATA[University of Texas at Austin]]></Name>
<CityName>AUSTIN</CityName>
<ZipCode>787121139</ZipCode>
<PhoneNumber>5124716424</PhoneNumber>
<StreetAddress><![CDATA[110 INNER CAMPUS DR]]></StreetAddress>
<StreetAddress2/>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<StateCode>TX</StateCode>
<CONGRESSDISTRICT>25</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>TX25</CONGRESS_DISTRICT_ORG>
<ORG_UEI_NUM>V6AFQPN18437</ORG_UEI_NUM>
<ORG_LGL_BUS_NAME>UNIVERSITY OF TEXAS AT AUSTIN</ORG_LGL_BUS_NAME>
<ORG_PRNT_UEI_NUM/>
</Institution>
<Performance_Institution>
<Name><![CDATA[The University of Texas at Austin]]></Name>
<CityName>Austin</CityName>
<StateCode>TX</StateCode>
<ZipCode>787595316</ZipCode>
<StreetAddress><![CDATA[3925 W Braker Lane, Suite 3340]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Texas</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>37</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>TX37</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>779600</Code>
<Text>Algorithmic Foundations</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7926</Code>
<Text>ALGORITHMS</Text>
</ProgramReference>
<ProgramReference>
<Code>7927</Code>
<Text>COMPLEXITY &amp; CRYPTOGRAPHY</Text>
</ProgramReference>
<Appropriation>
<Code>0120</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Fund>
<Code>01002021DB</Code>
<Name><![CDATA[NSF RESEARCH & RELATED ACTIVIT]]></Name>
<FUND_SYMB_ID>040100</FUND_SYMB_ID>
</Fund>
<FUND_OBLG>2020~400000</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>Randomness is surprisingly useful in computer science.&nbsp; It is used for Monte Carlo simulations of complex systems, such as the weather and the economy.&nbsp; It is essential to computer security.&nbsp; The fastest and simplest algorithms for many problems involve randomization.&nbsp; One example is testing whether a number is prime, a fundamental problem that's crucial in cryptography.<br />On the other hand, high-quality randomness is difficult to obtain.&nbsp; It's therefore natural to ask exactly how useful is randomness.&nbsp; For example, after much effort researchers did discover an efficient deterministic algorithm for primality, although it is still slower than the randomized one.&nbsp; Does every efficient randomized algorithm have an equivalent efficient deterministic algorithm?&nbsp; Short of that, can we convert our randomized algorithms into ones requiring few random bits?&nbsp; Or can we convert them into a robust form that will work with low-quality randomness?&nbsp; The tool to address the first two questions is a pseudorandom generator.&nbsp; The tool to address the last question is a randomness extractor.<br />In this project, the PI achieved significant progress in constructing randomness extractors and pseudorandom generators. First, the PI and coauthors studied a model of low-quality randomness introduced in the 1980s where every new bit, or block of bits, has some randomness conditioned on previous bits.&nbsp; In the 1980s researchers showed that it is impossible to extract high-quality randomness from this low-quality randomness. Nevertheless, we showed how to extract randomness that is close enough to high-quality for many applications.<br />Second, the PI and coauthors studied the problem of converting efficient randomized algorithms into efficient deterministic ones.&nbsp; There are well known obstacles to proving such a result unconditionally, so researchers have studied this problem while making certain lower bound assumptions.&nbsp; A large body of previous work showed how to do this conversion with a large polynomial slowdown.&nbsp; We showed how to do it with just a roughly quadratic slowdown, although we needed a stronger assumption.&nbsp; This led to a flurry of follow-up work.<br />The PI and coauthors had several other related results.&nbsp; Eventually, theoretical results along these lines will hopefully lead to advances in practice.</p><br> <p>  Last Modified: 01/12/2024<br> Modified by: David&nbsp;I&nbsp;Zuckerman</p></div> <div class="porSideCol" ></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  Randomness is surprisingly useful in computer science. It is used for Monte Carlo simulations of complex systems, such as the weather and the economy. It is essential to computer security. The fastest and simplest algorithms for many problems involve randomization. One example is testing whether a number is prime, a fundamental problem that's crucial in cryptography. On the other hand, high-quality randomness is difficult to obtain. It's therefore natural to ask exactly how useful is randomness. For example, after much effort researchers did discover an efficient deterministic algorithm for primality, although it is still slower than the randomized one. Does every efficient randomized algorithm have an equivalent efficient deterministic algorithm? Short of that, can we convert our randomized algorithms into ones requiring few random bits? Or can we convert them into a robust form that will work with low-quality randomness? The tool to address the first two questions is a pseudorandom generator. The tool to address the last question is a randomness extractor. In this project, the PI achieved significant progress in constructing randomness extractors and pseudorandom generators. First, the PI and coauthors studied a model of low-quality randomness introduced in the 1980s where every new bit, or block of bits, has some randomness conditioned on previous bits. In the 1980s researchers showed that it is impossible to extract high-quality randomness from this low-quality randomness. Nevertheless, we showed how to extract randomness that is close enough to high-quality for many applications. Second, the PI and coauthors studied the problem of converting efficient randomized algorithms into efficient deterministic ones. There are well known obstacles to proving such a result unconditionally, so researchers have studied this problem while making certain lower bound assumptions. A large body of previous work showed how to do this conversion with a large polynomial slowdown. We showed how to do it with just a roughly quadratic slowdown, although we needed a stronger assumption. This led to a flurry of follow-up work. The PI and coauthors had several other related results. Eventually, theoretical results along these lines will hopefully lead to advances in practice.     Last Modified: 01/12/2024       Submitted by: DavidIZuckerman]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
