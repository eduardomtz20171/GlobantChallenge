<?xml version="1.0" encoding="UTF-8"?>
<rootTag>
<Award>
<AwardTitle><![CDATA[SHF: Small: Programming with Semantic Revision Requests]]></AwardTitle>
<AGENCY>NSF</AGENCY>
<AwardEffectiveDate>06/01/2020</AwardEffectiveDate>
<AwardExpirationDate>05/31/2024</AwardExpirationDate>
<AwardTotalIntnAmount>499234.00</AwardTotalIntnAmount>
<AwardAmount>499234</AwardAmount>
<AwardInstrument>
<Value>Standard Grant</Value>
</AwardInstrument>
<Organization>
<Code>05010000</Code>
<Directorate>
<Abbreviation>CSE</Abbreviation>
<LongName>Direct For Computer &amp; Info Scie &amp; Enginr</LongName>
</Directorate>
<Division>
<Abbreviation>CCF</Abbreviation>
<LongName>Division of Computing and Communication Foundations</LongName>
</Division>
</Organization>
<ProgramOfficer>
<SignBlockName>Anindya Banerjee</SignBlockName>
<PO_EMAI>abanerje@nsf.gov</PO_EMAI>
<PO_PHON>7032927885</PO_PHON>
</ProgramOfficer>
<AbstractNarration>Software development today is a social process, and the workflow of&lt;br/&gt;programmers is increasingly centered around discussing program&lt;br/&gt;revisions - that is, artifacts that document small, incremental program&lt;br/&gt;changes. Meanwhile, traditional research on testing, debugging, and analyzing&lt;br/&gt;programs focuses on one program version at a time, ignoring any preceding or&lt;br/&gt;succeeding versions of the same software artifact. The project's novelties&lt;br/&gt;are a foundational examination of program revisions and the investigation of&lt;br/&gt;automated techniques that cooperatively assist software-engineering teams&lt;br/&gt;with reasoning about them. The project's impacts are to enhance the way&lt;br/&gt;engineering teams collaboratively evolve their software and thus enable them&lt;br/&gt;to more effectively create secure and reliable software on which society&lt;br/&gt;depends.&lt;br/&gt;&lt;br/&gt;The project's core contribution is defining the notion of a "semantic&lt;br/&gt;revision request" that enables treating program revisions as first-class&lt;br/&gt;entities for debugging and analysis tools. A semantic view of program&lt;br/&gt;revisions enables programmers to run or analyze the program revision (both&lt;br/&gt;before and after a change simultaneously), not merely each of the two program&lt;br/&gt;versions, as supported by today's conventional tools. By focusing on&lt;br/&gt;debugging and analyzing program revisions - not their individual program&lt;br/&gt;versions - the resulting tools come closer to capturing the intent of the&lt;br/&gt;programmer as they develop and commit program changes. The intended broader&lt;br/&gt;impact from a technical perspective is that these executable and analyzable&lt;br/&gt;specifications will supplement, or even replace, informal descriptions about&lt;br/&gt;how software systems evolve, by providing an unambiguous way to communicate&lt;br/&gt;high-level programmer intent.&lt;br/&gt;&lt;br/&gt;This award reflects NSF's statutory mission and has been deemed worthy of support through evaluation using the Foundation's intellectual merit and broader impacts review criteria.</AbstractNarration>
<MinAmdLetterDate>05/22/2020</MinAmdLetterDate>
<MaxAmdLetterDate>05/22/2020</MaxAmdLetterDate>
<ARRAAmount/>
<TRAN_TYPE>Grant</TRAN_TYPE>
<CFDA_NUM>47.070</CFDA_NUM>
<NSF_PAR_USE_FLAG>1</NSF_PAR_USE_FLAG>
<FUND_AGCY_CODE>4900</FUND_AGCY_CODE>
<AWDG_AGCY_CODE>4900</AWDG_AGCY_CODE>
<AwardID>2008369</AwardID>
<Investigator>
<FirstName>Bor-Yuh Evan</FirstName>
<LastName>Chang</LastName>
<PI_MID_INIT/>
<PI_SUFX_NAME/>
<PI_FULL_NAME>Bor-Yuh Evan Chang</PI_FULL_NAME>
<EmailAddress><![CDATA[evan.chang@colorado.edu]]></EmailAddress>
<NSF_ID>000512429</NSF_ID>
<StartDate>05/22/2020</StartDate>
<EndDate/>
<RoleCode>Principal Investigator</RoleCode>
</Investigator>
<Institution>
<Name><![CDATA[University of Colorado at Boulder]]></Name>
<CityName>Boulder</CityName>
<ZipCode>803090001</ZipCode>
<PhoneNumber>3034926221</PhoneNumber>
<StreetAddress><![CDATA[3100 MARINE ST]]></StreetAddress>
<StreetAddress2><![CDATA[STE 481 572 UCB]]></StreetAddress2>
<CountryName>United States</CountryName>
<StateName>Colorado</StateName>
<StateCode>CO</StateCode>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_ORG>CO02</CONGRESS_DISTRICT_ORG>
<ORG_UEI_NUM>SPVKK1RC2MZ3</ORG_UEI_NUM>
<ORG_LGL_BUS_NAME>THE REGENTS OF THE UNIVERSITY OF COLORADO</ORG_LGL_BUS_NAME>
<ORG_PRNT_UEI_NUM/>
</Institution>
<Performance_Institution>
<Name><![CDATA[University of Colorado Boulder]]></Name>
<CityName>Boulder</CityName>
<StateCode>CO</StateCode>
<ZipCode>803031058</ZipCode>
<StreetAddress><![CDATA[3100 Marine St, Room 481, 572 UC]]></StreetAddress>
<CountryCode>US</CountryCode>
<CountryName>United States</CountryName>
<StateName>Colorado</StateName>
<CountryFlag>1</CountryFlag>
<CONGRESSDISTRICT>02</CONGRESSDISTRICT>
<CONGRESS_DISTRICT_PERF>CO02</CONGRESS_DISTRICT_PERF>
</Performance_Institution>
<ProgramElement>
<Code>779800</Code>
<Text>Software &amp; Hardware Foundation</Text>
</ProgramElement>
<ProgramReference>
<Code>7923</Code>
<Text>SMALL PROJECT</Text>
</ProgramReference>
<ProgramReference>
<Code>7943</Code>
<Text>PROGRAMMING LANGUAGES</Text>
</ProgramReference>
<Appropriation>
<Code>0120</Code>
<Name>NSF RESEARCH &amp; RELATED ACTIVIT</Name>
<APP_SYMB_ID>040100</APP_SYMB_ID>
</Appropriation>
<Fund>
<Code>01002021DB</Code>
<Name><![CDATA[NSF RESEARCH & RELATED ACTIVIT]]></Name>
<FUND_SYMB_ID>040100</FUND_SYMB_ID>
</Fund>
<FUND_OBLG>2020~499234</FUND_OBLG>
<POR>
<DRECONTENT><![CDATA[<div class="porColContainerWBG"> <div class="porContentCol"><p>The goal of this project is to address a fundamental challenge in software development: understanding and verifying program revisions. Existing techniques to help developers reason automatically about their software typically considers the "before" and "after" versions of the program independently. However, this approach does not capture how modern software engineering works --- where engineers incrementally review revisions to an existing code base. This project investigates analyzing program revisions as first-class entities, enabling developers to reason about both versions simultaneously and gain deeper insights into how a change affects program behavior.</p> <p><br />Initially, the project focused on laying the groundwork for analyzing program revisions through incremental and demand-driven program analysis. The primary goal was to create techniques that could reuse results from analyzing the old version while targeting the reasoning on the new version to specific changes in question. The result was the Demanded Abstract Interpretation (DAI) framework, which provides an incremental and demand-driven approach to abstract interpretation, making it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine. A key result was doing so with a guarantee of being consistent with a from-scratch analysis result.</p> <p><br />Then, the project expanded on the initial framework by investigating the complexities of interprocedural analysis, that is, analysis that respects the procedural abstraction of software development, with an incremental and demand-driven analysis framework. By focusing on techniques for making summary-based interprocedural analysis demanded, the project arrived at an approach for incremental and demand-driven interprocedural analysis that again made it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine while guaranteeing from-scratch consistent results.</p> <p><br />Subsequently, the project pivoted slightly toward addressing the specific challenges posed by event-driven systems, such as mobile applications, which have become increasingly prevalent in modern software development. These systems often involve complex, asynchronous interactions between the app code and a large, opaque framework, making them particularly difficult to analyze. The project developed message history logics, a novel technique for reasoning about how an app interacts with its framework context. Unlike traditional approaches that require eager, up-front modeling of all possible interactions, message history logics allow the system to incrementally build a model of interactions as needed to verify specific properties or goals. This approach enabled the project to successfully demonstrate the identification bugs in a "before" version and the verification of the fix of the "after" version in several real, reported issues in open-source Android applications. All of these issues involve complex, multi-object and multi-callback interactions that were beyond the scope of prior approaches.</p><br> <p>  Last Modified: 11/10/2024<br> Modified by: Bor-Yuh Evan&nbsp;Chang</p></div> <div class="porSideCol" ></div> </div>]]></DRECONTENT>
<POR_COPY_TXT><![CDATA[  The goal of this project is to address a fundamental challenge in software development: understanding and verifying program revisions. Existing techniques to help developers reason automatically about their software typically considers the "before" and "after" versions of the program independently. However, this approach does not capture how modern software engineering works --- where engineers incrementally review revisions to an existing code base. This project investigates analyzing program revisions as first-class entities, enabling developers to reason about both versions simultaneously and gain deeper insights into how a change affects program behavior.    Initially, the project focused on laying the groundwork for analyzing program revisions through incremental and demand-driven program analysis. The primary goal was to create techniques that could reuse results from analyzing the old version while targeting the reasoning on the new version to specific changes in question. The result was the Demanded Abstract Interpretation (DAI) framework, which provides an incremental and demand-driven approach to abstract interpretation, making it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine. A key result was doing so with a guarantee of being consistent with a from-scratch analysis result.    Then, the project expanded on the initial framework by investigating the complexities of interprocedural analysis, that is, analysis that respects the procedural abstraction of software development, with an incremental and demand-driven analysis framework. By focusing on techniques for making summary-based interprocedural analysis demanded, the project arrived at an approach for incremental and demand-driven interprocedural analysis that again made it possible to reuse the same abstract domains from a classical batch analysis in a new incremental and demand-driven engine while guaranteeing from-scratch consistent results.    Subsequently, the project pivoted slightly toward addressing the specific challenges posed by event-driven systems, such as mobile applications, which have become increasingly prevalent in modern software development. These systems often involve complex, asynchronous interactions between the app code and a large, opaque framework, making them particularly difficult to analyze. The project developed message history logics, a novel technique for reasoning about how an app interacts with its framework context. Unlike traditional approaches that require eager, up-front modeling of all possible interactions, message history logics allow the system to incrementally build a model of interactions as needed to verify specific properties or goals. This approach enabled the project to successfully demonstrate the identification bugs in a "before" version and the verification of the fix of the "after" version in several real, reported issues in open-source Android applications. All of these issues involve complex, multi-object and multi-callback interactions that were beyond the scope of prior approaches.     Last Modified: 11/10/2024       Submitted by: Bor-Yuh EvanChang]]></POR_COPY_TXT>
</POR>
</Award>
</rootTag>
